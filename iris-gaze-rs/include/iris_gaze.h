// IRIS Gaze Tracking Library - C FFI Header
// Auto-generated by cbindgen - DO NOT EDIT
//
// This header provides the C interface to the Rust gaze tracking library.
// Include this in your Swift bridging header or use with a module map.


#ifndef IRIS_GAZE_H
#define IRIS_GAZE_H

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * MediaPipe landmark indices
 */
#define FaceLandmarks_NOSE_TIP 4

#define FaceLandmarks_FOREHEAD 10

#define FaceLandmarks_LEFT_EYE_TOP 159

#define FaceLandmarks_LEFT_EYE_BOTTOM 145

#define FaceLandmarks_LEFT_EYE_LEFT 33

#define FaceLandmarks_LEFT_EYE_RIGHT 133

#define FaceLandmarks_RIGHT_EYE_TOP 386

#define FaceLandmarks_RIGHT_EYE_BOTTOM 374

#define FaceLandmarks_RIGHT_EYE_LEFT 362

#define FaceLandmarks_RIGHT_EYE_RIGHT 263

/**
 * Error codes returned by the library
 */
typedef enum GazeError {
  /**
   * No error
   */
  None = 0,
  /**
   * Camera not found or failed to open
   */
  CameraError = 1,
  /**
   * Failed to load ML model
   */
  ModelError = 2,
  /**
   * No face detected in frame
   */
  NoFaceDetected = 3,
  /**
   * Invalid configuration
   */
  InvalidConfig = 4,
  /**
   * Internal error
   */
  InternalError = 5,
  /**
   * Tracker not initialized
   */
  NotInitialized = 6,
} GazeError;

/**
 * Status of the gaze tracker
 */
typedef enum TrackerStatus {
  /**
   * Tracker is not initialized
   */
  Uninitialized = 0,
  /**
   * Tracker is initializing (loading model, opening camera)
   */
  Initializing = 1,
  /**
   * Tracker is running and producing gaze data
   */
  Running = 2,
  /**
   * Tracker is paused
   */
  Paused = 3,
  /**
   * Tracker encountered an error
   */
  Error = 4,
  /**
   * Tracker is stopped
   */
  Stopped = 5,
} TrackerStatus;

/**
 * Opaque tracker handle for FFI
 */
typedef struct GazeTracker GazeTracker;

/**
 * Result of a single gaze tracking frame
 */
typedef struct GazeResult {
  /**
   * X coordinate on screen (0 to screen_width)
   */
  double x;
  /**
   * Y coordinate on screen (0 to screen_height)
   */
  double y;
  /**
   * Event type: 0=none, 1=gaze, 2=blink/wink
   */
  uint8_t event_type;
  /**
   * Whether this result is valid
   */
  bool valid;
} GazeResult;

typedef struct MPFaceLandmarker {

} MPFaceLandmarker;

/**
 * Initialize a new gaze tracker
 *
 * # Arguments
 * * `screen_width` - Width of the target screen in pixels
 * * `screen_height` - Height of the target screen in pixels
 * * `dominant_eye` - C string: "left" or "right"
 *
 * # Returns
 * Pointer to the tracker, or NULL on failure
 */

struct GazeTracker *iris_gaze_init(int32_t screen_width,
                                   int32_t screen_height,
                                   const char *dominant_eye)
;

/**
 * Get the next frame result from the tracker
 *
 * This function should be called in a loop (e.g., 60 times per second).
 * It captures a camera frame, detects landmarks, and returns gaze coordinates.
 *
 * # Arguments
 * * `tracker` - Pointer to the tracker (from iris_gaze_init)
 *
 * # Returns
 * GazeResult with coordinates and event type
 */
 struct GazeResult iris_gaze_get_frame(struct GazeTracker *tracker) ;

/**
 * Get the current status of the tracker
 */
 enum TrackerStatus iris_gaze_get_status(const struct GazeTracker *tracker) ;

/**
 * Get the last error code
 */
 enum GazeError iris_gaze_get_error(const struct GazeTracker *tracker) ;

/**
 * Stop the tracker (releases camera, etc.)
 */
 void iris_gaze_stop(struct GazeTracker *tracker) ;

/**
 * Destroy the tracker and free memory
 *
 * After calling this, the tracker pointer is invalid.
 */
 void iris_gaze_destroy(struct GazeTracker *tracker) ;

/**
 * Update the screen dimensions
 */
 void iris_gaze_set_screen_size(struct GazeTracker *tracker, int32_t width, int32_t height) ;

/**
 * Pause gaze tracking
 */
 void iris_gaze_pause(struct GazeTracker *tracker) ;

/**
 * Resume gaze tracking
 */
 void iris_gaze_resume(struct GazeTracker *tracker) ;

/**
 * Set calibration values directly
 *
 * # Arguments
 * * `tracker` - Pointer to the tracker
 * * `x_min` - Minimum nose X value (looking right)
 * * `x_max` - Maximum nose X value (looking left)
 * * `y_min` - Minimum forehead Y value (looking up)
 * * `y_max` - Maximum forehead Y value (looking down)
 */

void iris_gaze_set_calibration(struct GazeTracker *tracker,
                               double x_min,
                               double x_max,
                               double y_min,
                               double y_max)
;

/**
 * Set reach gain for easier corner access
 */
 void iris_gaze_set_reach_gain(struct GazeTracker *tracker, double gain_x, double gain_y) ;

/**
 * Get the current raw landmark values for calibration
 * Returns the nose X and forehead Y values from the last frame
 *
 * # Arguments
 * * `tracker` - Pointer to the tracker
 * * `nose_x` - Output: current nose X value
 * * `nose_y` - Output: current forehead Y value
 *
 * # Returns
 * true if values are valid, false otherwise
 */
 bool iris_gaze_get_raw_position(struct GazeTracker *tracker, double *nose_x, double *nose_y) ;

/**
 * Enable or disable auto-calibration mode
 * When enabled, the tracker will automatically adjust calibration based on observed values
 */
 void iris_gaze_set_auto_calibrate(struct GazeTracker *tracker, bool enabled) ;

extern struct MPFaceLandmarker *mp_face_landmarker_create(const char *model_path);

extern void mp_face_landmarker_destroy(struct MPFaceLandmarker *landmarker);

extern bool mp_face_landmarker_process(struct MPFaceLandmarker *landmarker,
                                       const uint8_t *rgb_data,
                                       int32_t width,
                                       int32_t height,
                                       float *out_landmarks,
                                       int32_t out_len);

#endif  /* IRIS_GAZE_H */
